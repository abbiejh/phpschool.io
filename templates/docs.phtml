<?= $this->fetch('includes/docs-header.phtml') ?>

<section class="site-body">
    <div class="container">
        <div class="docs">
            <ul class="doc__side">
                <li class="doc__side-item">
                    <a class="doc__side-link" href="#creating-your-own-workshop">Creating your own workshop</a>
                </li>
                <li class="doc__side-item">
                    <a class="doc__side-link" href="#modify-theme">Modifying the theme of your workshop</a>
                </li>
                <li class="doc__side-item">
                    <span class="doc__side-link" href="#creating-an-exercise">Creating an exercise</span>
                </li>
                <li class="doc__side-item">
                    <span class="doc__side-link" href="/api-docs">Available Services</span>
                </li>
                <li class="doc__side-item">
                    <a class="doc__side-link" href="#exercise-types">Exercise Types</a>
                </li>
                <li class="doc__side-item">
                    <span class="doc__side-link" href="#exercise-solutions">Exercise Solutions</span>
                </li>
                <li class="doc__side-item">
                    <span class="doc__side-link" href="/api-docs">Checks</span>
                </li>
                <li class="doc__side-item">
                    <span class="doc__side-link" href="/api-docs">Creating Custom Checks</span>
                </li>
                <li class="doc__side-item">
                    <span class="doc__side-link" href="/api-docs">Creating Custom Results</span>
                </li>
                <li class="doc__side-item">
                    <span class="doc__side-link" href="/api-docs">Creating Custom Result Renderers</span>
                </li>
                <li class="doc__side-item">
                    <span class="doc__side-link" href="/api-docs">API Reference</span>
                </li>
            </ul>
            <div class="doc__content">
                <h2 id="creating-your-own-workshop" class="doc__title">Creating your own workshop<a class="anchor" href="#creating-your-own-workshop">#</a></h2>
                <p>So.. You want to create your own workshop? You want to help teach a topic? You want to make a meetup more hands on? You want to showcase your tool? You've come to the right place!</p>

                <p>The first thing you need to do is to setup a new project and configure the dependencies and wire it all together. Luckily for you we have created a starter kit which does this all for you, prompting you along the way. Simply execute the following command in your shell.</p>

                <div class="terminal">
                    <div class="terminal-head">
                        <span class="terminal__button"></span>
                        <span class="terminal__button"></span>
                        <span class="terminal__button"></span>
                    </div>
                    <div class="terminal__body">
                        <p>composer create-project php-school/workshop-starter-kit &lt;your-workshop-name&gt;</p>
                    </div>
                </div>

                <p>Where <code>&lt;your-workshop-name&gt;</code> is the name of the directory you want to setup your workshop in. You will be prompted for a few things:</p>

                <h3>Composer package name</h3>
                <p>The name for your workshop to be put in the <code>composer.json</code> file. This usually the follows the syntax vendor/package. In the case of our flagship workshop <a target="_blank" href="https://github.com/php-school/learn-you-php">Learn You PHP!</a> this is <code>php-school/learn-you-php</code>.</p>
                <p>More info on the <code>name</code> property can be found <a target="_blank" href="https://getcomposer.org/doc/04-schema.md#name">here</a>.</p>

                <h3>Composer package description</h3>
                <p>A short description of your workshop which will be added to the <code>composer.json</code> file.</p>
                <p>More info on the <code>description</code> property can be found <a target="_blank" href="https://getcomposer.org/doc/04-schema.md#description">here</a>.</p>

                <h3>PHP Namespace for the source code</h3>
                <p>The namespace which will be used in the project so it can be added to the autoload configuration in the <code>composer.json</code> file. In the case of <a target="_blank" href="https://github.com/php-school/learn-you-php">Learn You PHP!</a> this is <code>PhpSchool\LearnYouPhp</code>.</p>

                <p>More info on the <code>autoload</code> property can be found <a target="_blank" href="https://getcomposer.org/doc/04-schema.md#psr-4">here</a>.</p>

                <h3>Workshop binary</h3>
                <p>This is the actual command users will execute to run your workshop. In the case of <a target="_blank" href="https://github.com/php-school/learn-you-php">Learn You PHP!</a> this is <code>learnyouphp</code></p>

                <hr>
                <p>After you have entered the required information the workshop dependencies will be downloaded and the autoload files will be generated.</p>

                <p class="note note-success">Assuming everything went well and your are in the root of your new workshop you should be able to run the workshop!</p>
                <div class="terminal">
                    <div class="terminal-head">
                        <span class="terminal__button"></span>
                        <span class="terminal__button"></span>
                        <span class="terminal__button"></span>
                    </div>
                    <div class="terminal__body">
                        <p>php bin/&lt;binary-name&gt;</p>
                    </div>
                </div>
                <p>Where <code>&lt;binary-name&gt;</code> is the name your previously entered during the <code>create-project</code> command.</p>
                <img src="img/post-install-workshop.png" class="doc-terminal-screen" id="post-install-workshop">

                <p class="note note-warning">If you don't see the menu above, then something went wrong. Get in touch with us and bring any helpful information such as error messages with you!</p>

                <h2 id="modify-theme" class="doc__title">Modifying the theme of your workshop<a class="anchor" href="#modify-theme">#</a></h2>
                <p>You can alter the colours, logo and text of your workshop very easily. Look in <code>app/bootstrap.php</code> and you should see the following code.</p>

                <pre><code class="lang-php">$app->setLogo($art);
$app->setFgColour('green');
$app->setBgColour('black');</code></pre>

                <p>You can modify any of these settings. Available colours are black, red, green, yellow, blue, magenta, cyan, white. <code>setLogo</code> takes a <code>string</code> and can be used display ascii art!</p>
                <p>You can set the title of your workshop which will be displayed on the terminal by changing the <code>null</code> argument to <code>Application</code> to a title of your choice. For example:</p>

                <pre><code class="lang-php">$app = new Application('My Workshop', __DIR__ . '/config.php');</code></pre>

                <h2 id="creating-an-exercise" class="doc__title">Creating an exercise<a class="anchor" href="#creating-an-exercise">#</a></h2>
                <p>An workshop is a bit useless without any exercises, so here we will learn how to create them. We will start off simple and then introduce more complicated exercises.</p>
                <p class="note note-success">It may be a good idea for exercises to start of simple and gradually increase in difficulty. You could try to explain concepts and build on them with each exercise.</p>

                <h3>Exercise checklist</h3>
                <ul>
                    <li>Decide on a topic to test.</li>
                    <li>Create a working solution.</li>
                    <li>Create a problem file.</li>
                    <li>Write the exercise.</li>
                </ul>

                <p>We will decide on a topic of basic PHP operators, more specifically working out the mean average of a given set of numbers.</p>

                <h3>Exercise specification</h3>
                <ul>
                    <li>The user should print out the mean average and nothing else. No new lines or whitespace.</li>
                    <li>The numbers should be random.</li>
                    <li>The amount of numbers should be random.</li>
                    <li>The numbers should be passed to the program as command line arguments.</li>
                </ul>

                <p>Given this specification we could write a program which would serve as our working solution.</p>
                <pre><code class="lang-php">&lt;?php
$count = 0;
for ($i = 1; $i < count($argv); $i++) {
    $count += $argv[$i];
}

$numberCount = count($argv) - 1;
echo $count / $numberCount;
</code></pre>
                <p>We should place this file in <code>exercises/mean/solution/solution.php</code></p>

                <p class="note note-success">Solution files are known, working programs which pass the exercise. When running a user's solution to an exercise, the known working solution is executed and the output compared to the users.</p>
                <p>The next step is to create a problem file. A problem file contains the instructions for the exercise. It should be a markdown file. This file is rendered int he terminal to the user when they select the exercise.</p>

                <h3>Tips for a good problem file</h3>
                <ul>
                    <li>Provide a solid description of the problem.</li>
                    <li>Provide some sample code which may need to be modified.</li>
                    <li>Provide hints and tips.</li>
                    <li>Provide links to the PHP documentation and good articles from reputable sources regarding key areas of the problem.</li>
                </ul>

                <p>Our problem file might look like the following.</p>
                <pre><code class="lang-md">Write a program that accepts one or more numbers as command-line arguments and prints the mean average of those numbers to the console (stdout).

----------------------------------------------------------------------
## HINTS

You can access command-line arguments via the global `$argv` array.

To get started, write a program that simply contains:

```php
var_dump($argv);
```

Run it with `php program.php` and some numbers as arguments. e.g:

```sh
$ php program.php 1 2 3
```

In which case the output would be an array looking something like:

```php
array(4) {
[0] =>
string(7) "program.php"
[1] =>
string(1) "1"
[2] =>
string(1) "2"
[3] =>
string(1) "3"
}
```

You'll need to think about how to loop through the number of arguments so you can output just their mean average. The first element of the `$argv` array is always the name of your script. eg `program.php`, so you need to start at the 2nd element (index 1), adding each item to the total until you reach the end of the array. You will then need to work out the average based on the amount of arguments given to you.

You can read how to work out an average here:
  [https://www.mathsisfun.com/mean.html]()

Also be aware that all elements of `$argv` are strings and you may need to *coerce* them into numbers. You can do this by prefixing the property with a cast `(int)` or just adding them. PHP will coerce it for you.

`{appname}` will be supplying arguments to your program when you run `{appname} verify program.php` so you don't need to supply them yourself. To test your program without verifying it, you can invoke it with `{appname} run program.php`. When you use `run`, you are invoking the test environment that `{appname}` sets up for each exercise.

----------------------------------------------------------------------
</code></pre>
                <p class="note note-info">Any instances of <code>{appname}</code> will be replaced with the actual application name, this will most likely be the configuration you set when creating your workshop.</p>
                <p>Drop this file in <code>exercises/mean/problem/problem.md</code>.</p>
                <p>Now we write the code, there is not much to it, but this is a simple exercise!</p>

                <pre><code class="lang-php">&lt;?php

namespace PhpSchool\SimpleMath\Exercise;

use PhpSchool\PhpWorkshop\Exercise\AbstractExercise;
use PhpSchool\PhpWorkshop\Exercise\CliExercise;
use PhpSchool\PhpWorkshop\Exercise\ExerciseInterface;
use PhpSchool\PhpWorkshop\Exercise\ExerciseType;

class Mean extends AbstractExercise implements ExerciseInterface, CliExercise
{

    /**
     * @return string
     */
    public function getName()
    {
        return 'Mean Average';
    }

    /**
     * @return string
     */
    public function getDescription()
    {
        return 'Simple Math';
    }

    /**
     * @return array
     */
    public function getArgs()
    {
        $numArgs = rand(0, 10);

        $args = [];
        for ($i = 0; $i < $numArgs; $i ++) {
            $args[] = rand(0, 100);
        }

        return $args;
    }

    /**
     * @return ExerciseType
     */
    public function getType()
    {
        return ExerciseType::CLI();
    }
}
</code></pre>
                <p>Now lets break this down.</p>
                <p>This class represents our exercise, it describes how the programs will be executed, the users and our known working program.</p>

                <h3>AbstractExercise</h3>
                <p>The <code>AbstractExercise</code> class implements a few interesting methods for us. Mainly <code>getSolution</code> and <code>getProblem</code>. These methods are responsible for locating your solution and problem files. By default they take your exercises name, normalise it (remove anything that is not A-Za-z or a dash, lowercase and replace spaces with dashes) and look in the <code>exercises/&lt;normalised-name&gt;/solution</code> and <code>exercises/&lt;normalised-name&gt;/problem</code> folders for files named <code>solution.php</code> and <code>problem.md</code> respectively. There maybe be cases when you need to override these methods, and in that case you probably don't need to extend from <code>AbstractExercise</code>.</p>
                <p class="note note-info">You may need to override the methods <code>getSolution</code> and <code>getProblem</code> if you want to organise your problems and solutions in a different structure. We would advise against this in the name of consistency but if you have a good enough reason then the option is there. There may also be the case that your solution is not simply one file. Jump over to <a href="#exercise-solutions">Exercise Solutions</a> to learn more, if that is the case.</p>

                <h3>Exercise Type</h3>
                <p>Each exercise must have a type, there are currently two types of exercise: CGI & CLI. Head over to <a href="#exercise-types">Exercise Types</a> to learn more. We are currently building a CLI type exercise, this means our solution and the users solution programs will be invoked using the PHP CLI binary. The arguments will come from out exercise. We inform the workshop of our exercise type by returning an instance of <code>ExerciseType</code> from the <code>getType</code> method. <code>ExerciseType</code> is an ENUM. In conjunction with this our exercise should implement the respective interface. For <code>cli</code> type exercises this is <code>CliExercise</code>.

                <h3>CliExercise</h3>
                <p>This interface defined one method: <code>getArgs</code>. This method should return an array of string arguments which will be passed to our solution and the user solutions and runtime. This method can return random records and rando numbers of arguments so that each time the user runs the verification process they receive different arguments. This makes sure the solution is robust.</p>
                <p class="note note-success">Try passing arguments which will test the boundaries of the users solution, for example using minimum and maximum values and using random values on each invocation.</p>
                <p class="note note-info">Do note that although your implementation of <code>getArgs</code> may return random arguments, your solution and the users solution will always receive the same arguments as the <code>getArgs</code> is only called once.</p>
                <p>Our exercise simply returns a random number of arguments between 0 and 10, each being a random number between 0 and 100.</p>

                <h3>Name and description</h3>
                <p>The remaining methods to implement are <code>getName</code> and <code>getDescription</code>. <code>getName</code> is the name of the exercise to be displayed in the menu and <code>getDescription</code> is a short description of the exercise. This is not actually used anywhere yet but is useful for when glancing through the code.</p>

                <h3>Registering the exercise and adding a factory</h3>
                <p>Internally, the workshop application uses a <a target="_blank" href="https://en.wikipedia.org/wiki/Dependency_Injection">dependency injection container</a>. This allows you to request other services from the application and replace services with your own implementations. In order for the application to locate your exercise, you need to register it with the application and also provide a factory for it. We use <a target="_blank" href="http://php-di.org">PHP-DI</a>.</p>
                <p>First, lets create a factory for our exercise. Open up <code>app/config.php</code>.</p>

                <pre><code lang="php">return [
    Mean::class => \DI\Object(),
];
</code></pre>
                <p>The file <code>app/config.php</code> should return an array of service definitions for the container. The key being the name of the service and the value the actual factory. For the case of exercises the service name should <strong>always</strong> be the class name. <code>\DI\Object()</code> is a helper function to create a factory which will simply run <code>new $yourClassName</code> when asking for the service from the container.</p>

                <p class="note note-success">See the section on <a href="#service-configuration">Service Configuration</a> for more information on factory definitions.</p>
                <div class="note note-success">
                    PHP-DI provides more powerful features such as being able to use anonymous functions and any callables as a factory. When using a callable your callable will be injected with the container itself which you can pull other services from!
                    <pre><code lang="php">return [
    Mean::class => \DI\factory(function (ContainerInterface $container) {
        return new Mean($container->get('someService');
    }),
];

</code></pre>
                </div>

                <p>You are almost done, we have registered the factory, essentially telling the application how to create your exercise. We just need to make it aware of your exercise. We do this in <code>app/bootstrap.php</code>. After the <code>Application</code> object is created you just call <code>addExercise</code> with the name of your exercise class. Your final <code>app/bootstrap.php</code> file should look something like the following:</p>
                <pre><code lang="php">&lt;?php
ini_set('display_errors', 1);
date_default_timezone_set('Europe/London');
switch (true) {
    case (file_exists(__DIR__ . '/../vendor/autoload.php')):
        // Installed standalone
        require __DIR__ . '/../vendor/autoload.php';
        break;
    case (file_exists(__DIR__ . '/../../../autoload.php')):
        // Installed as a Composer dependency
        require __DIR__ . '/../../../autoload.php';
        break;
    case (file_exists('vendor/autoload.php')):
        // As a Composer dependency, relative to CWD
        require 'vendor/autoload.php';
        break;
    default:
        throw new RuntimeException('Unable to locate Composer autoloader; please run "composer install".');
}

use PhpSchool\PhpWorkshop\Application;
use PhpSchool\SimpleMath\Exercise\Mean;

$app = new Application('Simple Math', __DIR__ . '/config.php');

$app->addExercise(Mean::class);

$app->setLogo('\(*-+)/');
$app->setFgColour('green');
$app->setBgColour('black');

return $app;
</code></pre>
                <p>That's it! You should now see your exercise in the menu when you run the app.</p>

                <div class="terminal">
                    <div class="terminal-head">
                        <span class="terminal__button"></span>
                        <span class="terminal__button"></span>
                        <span class="terminal__button"></span>
                    </div>
                    <div class="terminal__body">
                        <p>php bin/simple-math</p>
                    </div>
                </div>

                <img src="img/first-exercise.png" class="doc-terminal-screen" id="first-exercise">

                <h2 id="exercise-types" class="doc__title">Exercise Types<a class="anchor" href="#exercise-types">#</a></h2>
                <p>When an exercise is to be verified, there are two ways for the solution to be invoked. This is either CLI or CGI. Each exercise must have a type. This is used to determine how to invoke the script when verifying or running solutions. In order to explain the difference we will first show how a type translates to an actually php command.</p>
                <p>When selecting you exercise type you must return the valid type and implement the respective interface.</p>

                <h3>CLI</h3>
                <p>You choose the CLI type if you want the user to interact with the <code>$argv</code> and <code>$argc</code> super globals.</p>

                <table class="exercise__type__info">
                    <tbody>
                        <tr>
                            <td>Type</td>
                            <td><code>ExerciseType::CLI()</code></td>
                        </tr>
                        <tr>
                            <td>Interface</td>
                            <td><code>PhpSchool\PhpWorkshop\Exercise\CliExercise</code></td>
                        </tr>
                        <tr>
                            <td>Methods to implement</td>
                            <td><code>getArgs</code></td>
                        </tr>
                    </tbody>
                </table>

                <h4>Implementing getArgs</h4>
                <p><code>getArgs</code> should return an array of string. These are the arguments to be passed to the PHP CLI executable. The number of arguments which can be returned is not limited. All arguments should be strings.</p>

                <pre><code class="lang-php">&lt;?php

namespace PhpSchool\MyWorkshop\Exercise;

use PhpSchool\PhpWorkshop\Exercise\AbstractExercise;
use PhpSchool\PhpWorkshop\Exercise\CliExercise;
use PhpSchool\PhpWorkshop\Exercise\ExerciseInterface;
use PhpSchool\PhpWorkshop\Exercise\ExerciseType;

class MyExercise extends AbstractExercise implements ExerciseInterface, CliExercise
{
     ...snip

    /**
     * @return array
     */
    public function getArgs()
    {
        return ['arg1', 'arg2', 'arg3'];
    }

    /**
     * @return ExerciseType
     */
    public function getType()
    {
        return ExerciseType::CLI();
    }
}
</code></pre>
                <p>This exercise would cause PHP to be invoked like so:<p>
                <pre><code lang="sh">php solution.php 'arg1' 'arg2' 'arg3'</code></pre>

                <h3>CGI</h3>
                <p>You choose the CGI type if you want the user to interact with the <code>$_GET</code>, <code>$_POST</code>, <code>$_SERVER</code>, etc super globals.</p>
                <p>This exercise type allows to simulate a real HTTP request to a PHP script.</p>

                <table class="exercise__type__info">
                    <tbody>
                        <tr>
                            <td>Type</td>
                            <td><code>ExerciseType::CGI()</code></td>
                        </tr>
                        <tr>
                            <td>Interface</td>
                            <td><code>PhpSchool\PhpWorkshop\Exercise\CgiExercise</code></td>
                        </tr>
                        <tr>
                            <td>Methods to implement</td>
                            <td><code>getRequests</code></td>
                        </tr>
                    </tbody>
                </table>

                <h4>Implementing getRequests</h4>
                <p><code>getRequests</code> should return an array of PSR-7 Requests. The number of requests is not limited. Check <a target="_blank" href="http://www.php-fig.org/psr/psr-7/">here</a> for more information about PSR-7. The method is currently type hinted to return an array of the <a target="_blank" href="http://www.php-fig.org/psr/psr-7/#3-2-psr-http-message-requestinterface">Psr\Http\Message\RequestInterface</a> interface. You will need to use a library which implements the PSR-7 standard. Currently <a target="_blank" href="https://github.com/zendframework/zend-diactoros">zendframework/zend-diactoros</a> is shipped with <code>php-school/php-workshop</code> so you can just use that, or feel free to pull in a different implementation.</p>

                <h5>Simulating a GET request</h5>
                <pre><code class="lang-php">&lt;?php
namespace PhpSchool\MyWorkshop\Exercise;

use PhpSchool\PhpWorkshop\Exercise\AbstractExercise;
use PhpSchool\PhpWorkshop\Exercise\CgiExercise;
use PhpSchool\PhpWorkshop\Exercise\ExerciseInterface;
use PhpSchool\PhpWorkshop\Exercise\ExerciseType;
use Psr\Http\Message\RequestInterface;
use Zend\Diactoros\Request;

class MyExercise extends AbstractExercise implements ExerciseInterface, CgiExercise
{
    ...snip

    **
     * @return RequestInterface[]
     */
    public function getRequests()
    {
        return [
            (new Request('http://www.my-library.com?genre=punk&limit=50'))
                ->withMethod('GET')

        ];
    }

    /**
     * @return ExerciseType
     */
    public function getType()
    {
        return ExerciseType::CGI();
    }
}
</code></pre>
                <p>The request above will result in PHP super globals looking something like this:</p>
                <pre><code lang="php">//$_SERVER
array(13) {
    ["HTTP_HOST"] => string(18) "www.my-library.com"
    ["SCRIPT_FILENAME"] => string(57) "/root/path/your-workshop/get-solution.php"
    ["PWD"] => string(40) "/root/path/your-workshop"
    ["REDIRECT_STATUS"] => string(3) "302"
    ["SHLVL"] => string(1) "1"
    ["CONTENT_LENGTH"] => string(1) "0"
    ["QUERY_STRING"] => string(19) "genre=punk&limit=50"
    ["REQUEST_METHOD"] => string(3) "GET"
    ["_"] => string(48) "/usr/local/bin/php-cgi"
    ["__CF_USER_TEXT_ENCODING"] => string(13) "0x1F5:0x0:0x0"
    ["PHP_SELF"] => string(0) ""
    ["REQUEST_TIME_FLOAT"] => float(1458634262.4929)
    ["REQUEST_TIME"] => int(1458634262)
}

//$_GET
array(2) {
    ["genre"] => string(4) "punk"
    ["limit"] => string(2) "50"
}
</code></pre>
                <h5>Simulating a POST request</h5>
                <pre><code class="lang-php">&lt;?php

namespace PhpSchool\MyWorkshop\Exercise;

use PhpSchool\PhpWorkshop\Exercise\AbstractExercise;
use PhpSchool\PhpWorkshop\Exercise\CgiExercise;
use PhpSchool\PhpWorkshop\Exercise\ExerciseInterface;
use PhpSchool\PhpWorkshop\Exercise\ExerciseType;
use Psr\Http\Message\RequestInterface;
use Zend\Diactoros\Request;

class MyExercise extends AbstractExercise implements ExerciseInterface, CgiExercise
{
    ...snip

    /**
     * @return RequestInterface[]
     */
    public function getRequests()
    {
        $request1 = (new Request('http://www.my-library.com?genre=punk&limit=50'))
            ->withMethod('POST')
            ->withHeader('Content-Type', 'application/x-www-form-urlencoded');

        $request1->getBody()->write(urlencode(['genre' => 'punk', 'limit' => 200]));
        return [$request1];
    }

    /**
     * @return ExerciseType
     */
    public function getType()
    {
        return ExerciseType::CGI();
    }
}
</code></pre>
                <p>The request above will result in PHP super globals looking something like this:</p>
                <pre><code lang="php">//$_SERVER
 array(14) {
    ["HTTP_HOST"] => string(18) "www.my-library.com"
    ["SCRIPT_FILENAME"] => string(58) "/root/path/your-workshop/get-post-solution.php"
    ["HTTP_CONTENT_TYPE"] => string(33) "application/x-www-form-urlencoded"
    ["PWD"] => string(40) "/root/path/your-workshop"
    ["REDIRECT_STATUS"] => string(3) "302"
    ["SHLVL"] => string(1) "1"
    ["CONTENT_LENGTH"] => string(2) "17"
    ["CONTENT_TYPE"] => string(33) "application/x-www-form-urlencoded"
    ["REQUEST_METHOD"] => string(4) "POST"
    ["_"] => string(48) "/usr/local/bin/php-cgi"
    ["__CF_USER_TEXT_ENCODING"] => string(13) "0x1F5:0x0:0x0"
    ["PHP_SELF"] => string(0) ""
    ["REQUEST_TIME_FLOAT"] => double(1458845731.5657)
    ["REQUEST_TIME"] => int(1458845731)
 ["

 //$_POST
 array(2) {
    ["genre"] => string(4) "punk"
    ["limit"] => string(2) "50"
 }
</code></pre>
                <h4>How does this work?</h4>
                <p>We use the <code>php-cgi</code> binary to setup the PHP environment. The php-cgi use environment variables and stdin to configure itself, we export these variables based on the information you provide in <code>getRequests</code></p>

                <div class="note note-success">
                    <ul>
                        <li>You can return multiple request from <code>getRequests</code>.</li>
                        <li>Each request can have a different method.</li>
                        <li>Each request can have any amount of headers as you need.</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>
</section>
